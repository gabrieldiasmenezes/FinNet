package br.com.fiap.FinNet.controller;

import br.com.fiap.FinNet.model.Account;
import br.com.fiap.FinNet.components.AccountStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/accounts")
public class AccountController {
    private final Logger log = LoggerFactory.getLogger(getClass());
    private final List<Account> accounts = new ArrayList<>();
    private Long nextId = 1L;

    @GetMapping
    public List<Account> index() {
        return accounts;
    }

    @PostMapping
    @ResponseStatus(code = HttpStatus.CREATED)
    public ResponseEntity<Account> create(@RequestBody Account account) {
        log.info("Criando conta para " + account.getHoldName());
        account.setId(nextId++);
        account.setOpeningDate(java.time.LocalDate.now());
        account.setStatus(AccountStatus.ATIVA);
        accounts.add(account);
        return ResponseEntity.status(201).body(account);
    }

    @GetMapping("/{id}")
    public Account get(@PathVariable Long id) {
        log.info("Buscando conta " + id);
        return getAccount(id);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void destroy(@PathVariable Long id) {
        log.info("Deletando conta " + id);
        accounts.removeIf(account -> account.getId().equals(id));
    }

    @PutMapping("/close/{id}")
    public ResponseEntity<Account> closeAccount(@PathVariable Long id) {
        log.info("Encerrando conta " + id);
        Optional<Account> accountOpt = accounts.stream().filter(a -> a.getId().equals(id)).findFirst();
        if (accountOpt.isPresent()) {
            Account account = accountOpt.get();
            account.setStatus(AccountStatus.INATIVA);
            return ResponseEntity.ok(account);
        }
        return ResponseEntity.notFound().build();
    }

    @PutMapping("/deposit")
    public ResponseEntity<Account> deposit(@RequestParam Long id, @RequestParam Double amount) {
        log.info("Depositando " + amount + " na conta " + id);
        if (amount <= 0) {
            return ResponseEntity.badRequest().build();
        }
        Optional<Account> accountOpt = accounts.stream().filter(a -> a.getId().equals(id)).findFirst();
        if (accountOpt.isPresent()) {
            Account account = accountOpt.get();
            account.setInitialBalance(account.getInitialBalance() + amount);
            return ResponseEntity.ok(account);
        }
        return ResponseEntity.notFound().build();
    }

    @PutMapping("/withdraw")
    public ResponseEntity<Account> withdraw(@RequestParam Long id, @RequestParam Double amount) {
        log.info("Sacando " + amount + " da conta " + id);
        Optional<Account> accountOpt = accounts.stream().filter(a -> a.getId().equals(id)).findFirst();
        if (accountOpt.isPresent()) {
            Account account = accountOpt.get();
            if (amount <= 0 || account.getInitialBalance() < amount) {
                return ResponseEntity.badRequest().build();
            }
            account.setInitialBalance(account.getInitialBalance() - amount);
            return ResponseEntity.ok(account);
        }
        return ResponseEntity.notFound().build();
    }

    @PutMapping("/pix")
    public ResponseEntity<Account> pix(@RequestParam Long fromId, @RequestParam Long toId, @RequestParam Double amount) {
        log.info("Realizando PIX de " + amount + " da conta " + fromId + " para a conta " + toId);
        if (amount <= 0) {
            return ResponseEntity.badRequest().build();
        }
        Optional<Account> fromAccountOpt = accounts.stream().filter(a -> a.getId().equals(fromId)).findFirst();
        Optional<Account> toAccountOpt = accounts.stream().filter(a -> a.getId().equals(toId)).findFirst();
        if (fromAccountOpt.isPresent() && toAccountOpt.isPresent()) {
            Account fromAccount = fromAccountOpt.get();
            Account toAccount = toAccountOpt.get();
            if (fromAccount.getInitialBalance() < amount) {
                return ResponseEntity.badRequest().build();
            }
            fromAccount.setInitialBalance(fromAccount.getInitialBalance() - amount);
            toAccount.setInitialBalance(toAccount.getInitialBalance() + amount);
            return ResponseEntity.ok(fromAccount);
        }
        return ResponseEntity.notFound().build();
    }

    private Account getAccount(Long id) {
        return accounts.stream().filter(a -> a.getId().equals(id)).findFirst()
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));
    }
}
